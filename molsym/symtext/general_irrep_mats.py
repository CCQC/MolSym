import numpy as np
from numpy.linalg import matrix_power
from dataclasses import dataclass
from .point_group import PointGroup
from ..symtools import *

np.set_printoptions(precision=3, threshold=np.inf, linewidth=14000, suppress=True)
# New Symel definition!
@dataclass
class Symel():
    symbol:str
    vector:np.array # Not defined for E or i, axis vector for Cn and Sn, plane normal vector for sigma
    rrep:np.array
    m:int
    n:int
    O:str # Options: E, sigma_v, C_2', i, sigma_h
    def __str__(self) -> str:
        with np.printoptions(precision=5, suppress=True, formatter={"all":lambda x: f"{x:8.5f}"}):
            return f"\nSymbol: {self.symbol:>10s}: [{self.rrep[0,:]},{self.rrep[1,:]},{self.rrep[2,:]}]"
    def __repr__(self) -> str:
        return self.__str__()
    def __eq__(self, other):
        return self.symbol == other.symbol and np.isclose(self.rrep,other.rrep,atol=1e-10).all()

@dataclass 
class Irrep():
    symbol:str
    idx:int
    sub_idx:int

def pg_to_symels(PG):
    pg = PointGroup.from_string(PG)
    argerr = f"An invalid point group has been given or unexpected parsing of the point group string has occured: {pg.str}"
    z_axis = np.array([0,0,1])
    if pg.n is not None:
        n_is_even = (pg.n % 2 == 0)
        n_is_doubleeven = (pg.n % 4 == 0)
    if pg.family == "C":
        if pg.subfamily == "h":
            pass
        elif pg.subfamily == "v":
            if n_is_even:
                pass
            else:
                pass
        elif pg.subfamily == "s":
            pass
        elif pg.subfamily == "i":
            pass
        elif pg.subfamily is None:
            # Cn branch
            
            pass
        else:
            raise Exception(argerr)
    elif pg.family == "D":
        if pg.subfamily == "h":
            if n_is_even:
                pass
            else:
                pass
        elif pg.subfamily == "d":
            if n_is_even:
                pass
            else:
                pass
        elif pg.subfamily is None:
            if n_is_even:
                pass
            else:
                pass
        else:
            raise Exception(argerr)
    elif pg.family == "S":
        if pg.subfamily is None and n_is_even:
            if n_is_doubleeven:
                pass
        else:
            raise Exception(argerr)
    else:
        if pg.family == "T":
            if pg.subfamily == "h":
                pass
            elif pg.subfamily == "d":
                pass
            else:
                pass
        elif pg.family == "O":
            if pg.subfamily == "h":
                pass
            else:
                pass
        elif pg.family == "I":
            if pg.subfamily == "h":
                pass
            else:
                pass
        else:
            raise Exception(argerr)
    return 0

def epsilon(gamma):
    return np.exp(2 * np.pi * 1j / gamma)

def Zn(n, generator):
    # cyclic group generated by generator
    # Irreps: A1, A2, (B1, B2), E_1(1), E_1(2), E_2(1,2), ..., E_floor((n-1)/2)(1,2)
    x,y,z = np.eye(3)
    e = Symel("E", None, np.eye(3, dtype=np.float64), 0, n, "E")
    theta = 2*np.pi/n
    symels = [e]

    # Generate irrep labels
    irreps = [Irrep("A",None,None)]
    if n % 2 == 0:
        irreps.append(Irrep("B",None,None))
    i = 2
    while i < n:
        irreps.append(Irrep(f"E_{i>>1}(1)", i>>1, 1))
        irreps.append(Irrep(f"E_{i>>1}(2)", i>>1, 2))
        i += 2
    if n < 4:
        for irrep in irreps:
            irrep.symbol = irrep.symbol.replace("_1","")
    print(irreps)

    # Generate symels
    if generator == "C":
        cn1 = Symel(f"C_{n}", z, Cn(z, n), 1, n, "E")
        symels.append(cn1)
        for m in range(2,n):
            a,b = reduce(n, m)
            cnm = Symel(f"C_{a}^{b}".replace("^1",""), z, matrix_power(Cn(z,n),m), m, n, "E")
            symels.append(cnm)
    elif generator == "S":
        pass

    irrep_mats = {}
    for irrep in irreps:
        irrep_mats[irrep.symbol] = np.zeros((n,1,1), dtype=np.complex128)

    irrep_mats["A"] = np.ones((n,1,1))
    for idx, symel in enumerate(symels):
        for irrep in irreps:
            if irrep.symbol == "A":
                r = 1
            elif irrep.symbol == "B":
                r = (-1)**(symel.m)
            else:
                r = np.exp(2*np.pi*irrep.idx*symel.m*1j/n)
                if irrep.sub_idx == 2:
                    r = np.conj(r)
            irrep_mats[irrep.symbol][idx][0,0] = r
    for irrep in irreps:
        print(irrep_mats[irrep.symbol].flatten())
    return symels